<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Editor Visuale Labirinto: {{ project_name }}</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <style>
        :root {
            --cell-size: 30px;
            --wall-color: #4a4a4a;
            --path-color: #e9ecef;
            --start-color: #28a745;
            --end-color: #ffc107;
        }
        body > main { padding: 1rem; }
        .container { max-width: 1200px; margin: auto; }
        nav { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem; }
        
        .editor-layout { display: grid; grid-template-columns: 200px 1fr; gap: 2rem; }
        .tool-palette button { width: 100%; margin-bottom: 0.5rem; }
        .tool-palette button.active { background-color: var(--primary); color: var(--primary-inverse); }

        #maze-grid { display: grid; border: 2px solid #333; cursor: crosshair; }
        .maze-cell { width: var(--cell-size); height: var(--cell-size); box-sizing: border-box; }
        .maze-cell.wall { background-color: var(--wall-color); }
        .maze-cell.path { background-color: var(--path-color); }
        .maze-cell.start { background-color: var(--start-color); }
        .maze-cell.end { background-color: var(--end-color); display: flex; justify-content: center; align-items: center; }
        .maze-cell.end::before { content: '⭐'; font-size: calc(var(--cell-size) * 0.7); }

        .level-tabs { margin-bottom: 1rem; }
        .level-tabs button { margin-right: 0.5rem; }
        .level-tabs button.active { background-color: var(--primary-focus); border-color: var(--primary-focus); }

        .dimension-controls { margin-top: 1rem; }
        .dimension-controls .grid { gap: 0.5rem; }
    </style>
</head>
<body>
    <main class="container">
        <nav>
            <div>
                <a href="{{ url_for('dashboard') }}">← Dashboard</a>
                <a href="{{ url_for('edit_project', project_name=project_name) }}" style="margin-left: 1rem;">Editor Codice</a>
            </div>
            <button id="save-all-btn">Salva Tutte le Modifiche</button>
        </nav>

        <h1>Editor Visuale Labirinto per <em>{{ project_name }}</em></h1>

        <div class="level-tabs" id="level-tabs-container"></div>
        <button id="add-level-btn" class="outline secondary" style="margin-bottom: 2rem;">+ Aggiungi Livello</button>

        <div class="editor-layout">
            <aside class="tool-palette">
                <strong>Strumenti</strong>
                <div id="tool-palette-container">
                    <button data-tool="wall" class="tool-btn active">Muro</button>
                    <button data-tool="path" class="tool-btn">Percorso</button>
                    <button data-tool="start" class="tool-btn">Partenza</button>
                    <button data-tool="end" class="tool-btn">Fine</button>
                </div>
                <hr>
                <strong>Dimensioni</strong>
                <div class="dimension-controls">
                    <div class="grid">
                        <button id="add-row-btn">+ Riga</button>
                        <button id="remove-row-btn" class="secondary">- Riga</button>
                    </div>
                    <div class="grid">
                        <button id="add-col-btn">+ Colonna</button>
                        <button id="remove-col-btn" class="secondary">- Colonna</button>
                    </div>
                </div>
            </aside>
            <section>
                <label for="instruction-input"><strong>Istruzione del livello</strong></label>
                <input type="text" id="instruction-input" placeholder="Guida la pallina fino alla stella!">
                <div id="maze-grid"></div>
            </section>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Elementi del DOM
            const mazeGrid = document.getElementById('maze-grid');
            const toolPalette = document.getElementById('tool-palette-container');
            const saveBtn = document.getElementById('save-all-btn');
            const instructionInput = document.getElementById('instruction-input');
            const levelTabsContainer = document.getElementById('level-tabs-container');
            const addLevelBtn = document.getElementById('add-level-btn');

            // Stato dell'editor
            const projectName = '{{ project_name }}';
            let gameData = JSON.parse('{{ game_data | tojson | safe }}');
            let currentLevelIndex = 0;
            let selectedTool = 'wall';
            let isPainting = false;

            function render() {
                if (!gameData || gameData.length === 0) {
                    gameData = [{ instruction: "Nuovo labirinto", layout: [["start", "path", "end"], ["wall", "path", "wall"]] }];
                }
                renderLevelTabs();
                renderCurrentLevel();
            }

            function renderLevelTabs() {
                levelTabsContainer.innerHTML = '';
                gameData.forEach((_, index) => {
                    const tab = document.createElement('button');
                    tab.textContent = `Livello ${index + 1}`;
                    tab.className = (index === currentLevelIndex) ? 'active' : '';
                    tab.onclick = () => {
                        syncInstruction();
                        currentLevelIndex = index;
                        render();
                    };
                    levelTabsContainer.appendChild(tab);
                });
            }

            function renderCurrentLevel() {
                const level = gameData[currentLevelIndex];
                if (!level) return;

                instructionInput.value = level.instruction;
                const layout = level.layout;
                const rows = layout.length;
                const cols = layout[0].length;

                mazeGrid.innerHTML = '';
                mazeGrid.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;

                layout.forEach((row, y) => {
                    row.forEach((cellType, x) => {
                        const cell = document.createElement('div');
                        cell.className = `maze-cell ${cellType}`;
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        mazeGrid.appendChild(cell);
                    });
                });
            }

            function syncInstruction() {
                if (gameData[currentLevelIndex]) {
                    gameData[currentLevelIndex].instruction = instructionInput.value;
                }
            }

            function handleCellPaint(e) {
                if (!e.target.classList.contains('maze-cell')) return;
                const cell = e.target;
                const x = parseInt(cell.dataset.x, 10);
                const y = parseInt(cell.dataset.y, 10);
                const currentLayout = gameData[currentLevelIndex].layout;
                const oldType = currentLayout[y][x];

                // Se lo strumento è 'start' o 'end', rimuovi il vecchio per garantirne l'unicità
                if (selectedTool === 'start' || selectedTool === 'end') {
                    currentLayout.forEach((row, ry) => {
                        row.forEach((c, rx) => {
                            if (c === selectedTool) currentLayout[ry][rx] = 'path';
                        });
                    });
                }

                currentLayout[y][x] = selectedTool;
                renderCurrentLevel(); // Ridisegna per mostrare le modifiche
            }

            // Gestione della palette di strumenti
            toolPalette.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    toolPalette.querySelector('.active').classList.remove('active');
                    e.target.classList.add('active');
                    selectedTool = e.target.dataset.tool;
                }
            });

            // Gestione del "disegno" sul labirinto
            mazeGrid.addEventListener('mousedown', (e) => {
                isPainting = true;
                handleCellPaint(e);
            });
            mazeGrid.addEventListener('mouseover', (e) => {
                if (isPainting) handleCellPaint(e);
            });
            document.addEventListener('mouseup', () => { isPainting = false; });
            mazeGrid.addEventListener('mouseleave', () => { isPainting = false; });

            // Gestione aggiunta/rimozione livelli
            addLevelBtn.addEventListener('click', () => {
                syncInstruction();
                gameData.push({ instruction: "Nuovo labirinto", layout: [["start", "path", "end"], ["wall", "path", "wall"]] });
                currentLevelIndex = gameData.length - 1;
                render();
            });

            // Gestione dimensioni
            document.getElementById('add-row-btn').addEventListener('click', () => {
                const layout = gameData[currentLevelIndex].layout;
                const cols = layout[0].length;
                layout.push(Array(cols).fill('path'));
                renderCurrentLevel();
            });
            document.getElementById('remove-row-btn').addEventListener('click', () => {
                const layout = gameData[currentLevelIndex].layout;
                if (layout.length > 1) layout.pop();
                renderCurrentLevel();
            });
            document.getElementById('add-col-btn').addEventListener('click', () => {
                gameData[currentLevelIndex].layout.forEach(row => row.push('path'));
                renderCurrentLevel();
            });
            document.getElementById('remove-col-btn').addEventListener('click', () => {
                const layout = gameData[currentLevelIndex].layout;
                if (layout[0].length > 1) layout.forEach(row => row.pop());
                renderCurrentLevel();
            });

            // Salvataggio
            saveBtn.addEventListener('click', async () => {
                syncInstruction(); // Salva l'ultima istruzione modificata
                saveBtn.disabled = true;
                saveBtn.textContent = 'Salvataggio...';
                try {
                    const response = await fetch(`/api/project/${projectName}/visual_data`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(gameData)
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.error || 'Errore sconosciuto');
                    alert(result.message);
                } catch (error) {
                    alert(`Errore durante il salvataggio: ${error.message}`);
                } finally {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'Salva Tutte le Modifiche';
                }
            });

            // Avvio
            render();
        });
    </script>
</body>
</html>